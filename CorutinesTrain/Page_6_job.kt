package corutines

import kotlinx.coroutines.*

/* билдер корутин launch возвращает объект Job. С помощью этого объекта можно управлять запущенной корутиной.
Самый простой способ обратиться к объекту Job это дать корутине имя.
Например: val job: Job = launch{ какой-то код }. В основном называется просто job, но конечно это не обязательно.
Можно придумать и своё имя - например val myCoroutine: Job = launch{ какой-то код }.

Чаще всего обращаются к следующим методам
join() - дождаться завершения корутины
start() - начать выполнения корутины
cancel() - закрыть корутину

рассмотрим на небольших примерах
* */

suspend fun main() {

/*
* Допустим у нас есть две переменные и в корутинах мы хотим присудить им какое-то значение, на выполнение этого когда
* условно затратим 2 секунды. В первом примере выполним умножение, и окажется что производится умножение дефолтных
* значений. Потому что корутины еще не выполнили свой блок кода и не присудили новые значения (просто не успели),
* а программа уже пошла дальше.
* Во втором примере сделаем всё то же самое. Но теперь обратимся к job корутин, и выполним метод join().
* Т.е. код который находится ниже этого метода не будет выполняться, пока корутина не закончит свои вычисления.*
*  */
    var firstNumber = 0
    var secondNumber = 0

    // пример 1
    coroutineScope {
        println("Пример 1")
        println("Начинаю вычисления:")

        launch {
            // через 2 секунды присуждаем новое значения для переменной firstNumber
            delay(2000)
            firstNumber = (10..100).random()
        }

        launch {
            // через 2 секунды присуждаем новое значения для переменной secondNumber
            delay(2000)
            secondNumber = (10..100).random()
        }

        // корутины не успели выполнить свой код. Поэтому будут умножены дефолтные значения 0*0
        val result = firstNumber * secondNumber
        println("Вычисления из первого примера произведены. Результат - $result")

    }

    // пример 2
    coroutineScope {
        println("Пример 2")
        println("Начинаю вычисления:")

        val firstNumberJob: Job = launch {
            delay(2000)
            firstNumber = (10..100).random()
        }

        val secondNumberJob: Job = launch {
            delay(2000)
            secondNumber = (10..100).random()
        }

        // дожидаемся пока корутины не выполнят свои вычисления
        firstNumberJob.join()
        secondNumberJob.join()
        // когда ожидаем выполнения нескольких корутин можно написать проще - joinAll(firstNumberJob, secondNumberJob)


        // и только после этого запускаем этот участок кода
        val result = firstNumber * secondNumber
        println("Вычисления из второго примера произведены. Результат - $result")

    }


}